---
title: "Feature Engineering com s√©ries de pre√ßos de ativos financeiros"
format:
  html:
    css: styles.css
    self-contained: true
    toc: true
    code-fold: true
    df-print: paged
editor: visual
---

------------------------------------------------------------------------

<left> ![](https://raw.githubusercontent.com/profrhozon/site/main/logo_FAE.png){width="15%"} </left>

------------------------------------------------------------------------

```         
```

::: callout-note
## Resumo

Este documento apresenta o processo de Feature Engineering aplicado a dados de s√©ries temporais financeiras, contemplando:

-   Download de dados de commodities via `yahooquery`
-   C√°lculo de log-retornos e an√°lise de distribui√ß√µes (assimetria, histograma)
-   Modelagem GARCH(1,1) para estimar vari√¢ncia condicional
-   Visualiza√ß√£o de resultados utilizando `timetk` no R
:::

## üìå Introdu√ß√£o: Feature Engineering em dados de s√©ries financeiras

```{=html}
<!-- 
Escrever a intro do documento aqui ....
-->
```

### Medindo a Volatilidade: Com e Sem GARCH

A abordagem tradicional calcula a volatilidade como o desvio padr√£o dos retornos hist√≥ricos em uma janela m√≥vel de tamanho $N$: (dias de negocia√ß√£o)

$$
\sigma_{\text{hist}} = \sqrt{\frac{1}{N-1}\sum_{i=1}^{N}(r_i - \bar{r})^2}
$$

**Vantagens:**

-   Simplicidade e facilidade de implementa√ß√£o.

**Desvantagens:**

-   Assume volatilidade constante durante a janela. (ou seja precisa de um range dias e n√£o √© capaz de medir o desvio ou o risco/volatilidade de um dia pro outro.)

-   N√£o capta a persist√™ncia dos choques (efeito de clustering).

-   N√£o reage dinamicamente a choques recentes.

### Volatilidade com o GARCH

O modelo GARCH(1,1) estima a vari√¢ncia condicional de forma din√¢mica:

$$
\sigma_t^2 = \omega + \alpha \epsilon_{t-1}^2 + \beta \sigma_{t-1}^2.
$$

Onde: - $\epsilon_{t-1}^2$ reflete o impacto dos choques recentes. - $\sigma_{t-1}^2$ reflete a persist√™ncia da volatilidade do per√≠odo anterior. - $\omega > 0$, $\alpha \geq 0$ e $\beta \geq 0$ s√£o par√¢metros estimados.

A soma $\alpha + \beta$ mede a persist√™ncia total da volatilidade:

-   **Pr√≥ximo de 1:** Choques t√™m efeitos duradouros; a volatilidade permanece alta por v√°rios per√≠odos.

-   **Menor que 1:** Os choques se dissipam mais rapidamente; a volatilidade retorna ao seu n√≠vel m√©dio mais r√°pido.

**Vantagens do GARCH:**

-   Modela a volatilidade de forma din√¢mica.

-   Captura o efeito de "clustering" dos choques.

-   Permite previs√µes mais precisas da volatilidade futura.

**Desvantagens do GARCH:**

-   Requer estima√ß√£o de par√¢metros e pressup√µe uma estrutura espec√≠fica para a volatilidade.

-   Pode ser sens√≠vel √† escolha da distribui√ß√£o dos res√≠duos (por exemplo, normal vs. $t$ de Student).

::: panel-tabset
## Python

```{python}

#import yfinance as yf
from yahooquery import Ticker
import pandas as pd
import numpy as np
#import matplotlib.pyplot as plt
#import seaborn as sns
from datetime import datetime
from arch import arch_model # Lib do Python pra estimar as volatilidades (ARCH/GARCH)
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from plotnine import ggplot, aes, geom_line, facet_wrap, labs, theme, element_text, theme_minimal

```

```{python}

# Tickers for portfolio
TICKERS = [
  "BRFS3.SA",
  "JBSS3.SA",
  "BEEF3.SA",
  "MRFG3.SA",
  "TSN",
  "HRL",
  "GIS"
]

# Baixar os dados hist√≥ricos com yahooquery
tickers = Ticker(TICKERS)
data = tickers.history(period="5y")

# Resetar o √≠ndice corretamente
data = data.reset_index()

# O yahooquery retorna um MultiIndex, ent√£o √© preciso garantir que a coluna "date" exista corretamente
if "date" not in data.columns:
    raise ValueError("A coluna 'date' n√£o foi encontrada no dataset! Verifique a estrutura do DataFrame.")

# Selecionar apenas as colunas de interesse e reformatar
portfolio_prices = data.pivot(index="date", columns="symbol", values="close").reset_index()

# Garantir que n√£o h√° valores ausentes
portfolio_prices.dropna(inplace=True)

portfolio_prices.head()

```

Plotamos os gr√°ficos das s√©ries temporais de pre√ßos

```         
```

```{python}
#| eval: false

# Retire o comando #| eval: false pra conseguir executar essa celula dentro do Quarto
import plotly.express as px

# Certifique-se de que a coluna "date" est√° em formato datetime
portfolio_prices['date'] = pd.to_datetime(portfolio_prices['date'])

# Transformar os pre√ßos para o formato longo (melt) para facilitar o plot
prices_long = portfolio_prices.melt(id_vars='date', var_name='Ativo', value_name='Valor')

fig = px.line(prices_long, x='date', y='Valor', color='Ativo',
              title='S√©ries Temporais de Pre√ßos')
fig.show()


```

mas essas s√©ries temporais tem um problema....os pre√ßos est√£o em seus "n√≠veis", e isso em an√°lise de s√©ries temporais n√£o √© o ideal. Precisamos trabalhar com as s√©ries estacion√°rias e analisar os retornos dos pre√ßos.

*A stationary time series is one whose statistical properties do not depend on the time at which the series is observed.18 Thus, time series with trends, or with seasonality, are not stationary ‚Äî the trend and seasonality will affect the value of the time series at different times. On the other hand, a white noise series is stationary ‚Äî it does not matter when you observe it, it should look much the same at any point in time.*

*Some cases can be confusing ‚Äî a time series with cyclic behaviour (but with no trend or seasonality) is stationary. This is because the cycles are not of a fixed length, so before we observe the series we cannot be sure where the peaks and troughs of the cycles will be.*

*In general, a stationary time series will have no predictable patterns in the long-term. Time plots will show the series to be roughly horizontal (although some cyclic behaviour is possible), with constant variance.*

(Hyndman, R.J., & Athanasopoulos, G. (2021) **Forecasting: principles and practice**, 3rd edition, OTexts: Melbourne, Australia. <https://otexts.com/fpp3/stationarity.html>. Accessed on 2025/march.)

Estacionar uma s√©rie temporal econ√¥mica √© importante pois:

*"Uma s√©rie temporal √© dita estacion√°ria se suas propriedades estat√≠sticas, como a m√©dia e a vari√¢ncia, permanecem constantes ao longo do tempo. Em outras palavras, n√£o h√° uma tend√™ncia determin√≠stica na s√©rie, e as flutua√ß√µes ao redor da m√©dia s√£o est√°veis. Se a s√©rie n√£o for estacion√°ria, suas previs√µes podem ser pouco confi√°veis, pois os padr√µes passados podem n√£o ser representativos do futuro."* (Gujarati & Porter, 2009, p. 753).

```{python}

# Calcular os log-retornos
log_returns = portfolio_prices.copy()
log_returns.iloc[:, 1:] = np.log(portfolio_prices.iloc[:, 1:]).diff()

# Remover a primeira linha que cont√©m NaN ap√≥s a diferencia√ß√£o
log_returns = log_returns.dropna()

```

```         
```

```{python}
#| eval: false

# Retire o comando #| eval: false pra conseguir executar essa celula dentro do Quarto
# Garantir que a coluna "date" esteja em formato datetime
log_returns['date'] = pd.to_datetime(log_returns['date'])

# Transformar para formato longo
log_returns_long = log_returns.melt(id_vars='date', var_name='Ativo', value_name='Log_Retorno')

fig = px.line(log_returns_long, x='date', y='Log_Retorno', color='Ativo',
              title='S√©ries Temporais de Log-Retornos')
fig.show()


```

Analisar as distribui√ß√µes dos retornos √© fundamental para entender o comportamento estat√≠stico dos ativos financeiros. Essa an√°lise nos permite identificar caracter√≠sticas importantes, como a presen√ßa de assimetria e caudas pesadas. <mark>Por exemplo, uma assimetria negativa indica que os retornos tendem a oscilar mais para valores baixos, sugerindo um risco maior de perdas acentuadas, enquanto uma assimetria positiva indica uma tend√™ncia para oscila√ß√µes para valores mais altos</mark>. Al√©m disso, observar a forma da distribui√ß√£o ajuda a avaliar se a hip√≥tese de normalidade √© v√°lida ou se √© necess√°rio adotar distribui√ß√µes alternativas, como a distribui√ß√£o $t$ de Student, que captura melhor a ocorr√™ncia de eventos extremos. Essa compreens√£o √© crucial para a modelagem de riscos, desenvolvimento de estrat√©gias de investimento e aprimoramento dos modelos econom√©tricos utilizados na previs√£o dos pre√ßos.

```{python}

# Seleciona apenas as colunas dos ativos (excluindo a coluna "date")
ativos = log_returns.columns[1:]

# Calcula a assimetria para cada ativo
skewness = log_returns[ativos].skew()

# Cria um DataFrame para visualizar os resultados
skew_table = pd.DataFrame({
    'Ativo': skewness.index,
    'Skewness': skewness.values
})

# Adiciona a coluna que indica a dire√ß√£o da assimetria
skew_table['Direcao'] = skew_table['Skewness'].apply(
    lambda x: '√Ä direita' if x > 0 else ('√Ä esquerda' if x < 0 else 'Sim√©trica')
)

# Exibe a tabela atualizada
skew_table

```

Agora teremos que ver se o range de nossa sele√ß√£o de an√°lise ter√° mais retornos positivos do que negativos, olhando os histogramas:

```         
```

```{python}
#| eval: false

# Retire o comando #| eval: false caso queira executar essa celula

import seaborn as sns
import matplotlib.pyplot as plt

# Transformar os log-retornos para formato longo (melt)
log_returns_long = log_returns.melt(id_vars=["date"], var_name="Ativo", value_name="Log_Retorno")

# Criar gr√°fico com Seaborn
plt.figure(figsize=(12, 8))
g = sns.FacetGrid(log_returns_long, col="Ativo", col_wrap=2, sharex=False, sharey=False)
g.map_dataframe(sns.histplot, x="Log_Retorno", kde=True, bins=30, color="black", alpha=0.5)

# Ajustar t√≠tulo dos gr√°ficos
g.set_titles(col_template="{col_name}")

# Melhorar layout
plt.tight_layout()
plt.show()

```

Como medida de risco, utilizamos as vari√¢ncias condicionais (volatilidades) para lidar melhor com a varia√ß√£o di√°ria dos log-retornos dos pre√ßos.

### Volatilidade com desvio-padr√£o

A volatilidade hist√≥rica pode ser medida como o desvio-padr√£o dos log-retornos calculado em uma janela m√≥vel de $N$ dias de negocia√ß√£o.

Neste exemplo, adotamos uma janela m√≥vel de 5 dias (aproximadamente uma semana de negocia√ß√£o. Para um m√™s de negocia√ß√£o, utilizar 22 e um ano 252) para capturar a volatilidade di√°ria dos ativos.

**Vantagens:**

-   Simplicidade e facilidade de implementa√ß√£o.

**Desvantagens:**

-   Assume volatilidade constante durante a janela.

-   N√£o capta a persist√™ncia dos choques.

-   N√£o reage dinamicamente a choques recentes.

```{python}

# Calcular a volatilidade hist√≥rica com uma janela m√≥vel de 5 dias

# Supondo que 'log_returns' j√° foi calculado e possui a coluna 'date' e os log-retornos dos ativos
window = 5

# Cria um DataFrame para armazenar a volatilidade hist√≥rica
vol_hist = pd.DataFrame({'date': log_returns["date"]})

# Calcula o desvio-padr√£o m√≥vel (volatilidade) para cada ativo
for col in log_returns.columns[1:]:
    vol_hist[col] = log_returns[col].rolling(window=window).std()

# Exibe as ultimas linhas do DataFrame de volatilidade hist√≥rica
#print(vol_hist.head()) # 5 primeiros ser√£o NaN
print(vol_hist.tail())

```

Plotando temos:

```         
```

```{python}
#| eval: false

# Retire o comando #| eval: false pra conseguir executar essa celula dentro do Quarto
# Certificar que "date" √© datetime (j√° feito)
vol_hist['date'] = pd.to_datetime(vol_hist['date'])

# Transformar para formato longo
vol_hist_long = vol_hist.melt(id_vars='date', var_name='Ativo', value_name='Volatilidade_Hist')

fig = px.line(vol_hist_long, x='date', y='Volatilidade_Hist', color='Ativo',
              title='Volatilidade Hist√≥rica (Desvio-Padr√£o) com janela de 5 dias')
fig.show()

```

### Volatilidade com GARCH(1,1)

O desvio-padr√£o assume que precisaremos de um range maior do que 2 pontos no tempo, o que limita nossa an√°lise pois a incompatibiliza, uma vez que precisaremos comparar os riscos di√°rios x retornos di√°rios (como feito anteriormente). Ou seja, n√£o podemos comparar retornos dia-a-dia x volatilidades (risco) de 5 em 5 dias p. ex.

Os modelos heteroced√°sticos (da fam√≠lia ARCH) estimam a vari√¢ncia condicional dos nossos dados, ou seja, em linguagem de finan√ßas, eles s√£o capazes de capturar as volatilidades ou risco dos retornos dos pre√ßos de ativos financeiros ponto a ponto no tempo, ou seja, dia a dia.

O modelo GARCH(1,1) com distribui√ß√£o $t$ assim√©trica n√£o est√° dispon√≠vel diretamente na maioria das bibliotecas Python. No entanto, podemos utilizar um GARCH(1,1) com uma distribui√ß√£o $t$ padr√£o para estimar a vari√¢ncia condicional. O modelo √© representado por:

$$
r_t = \mu + \epsilon_t
$$

$$
\epsilon_t = \sigma_t z_t, \quad z_t \sim t_{\nu}(0, 1)
$$

$$
\sigma_t^2 = \omega + \alpha \epsilon_{t-1}^2 + \beta \sigma_{t-1}^2
$$

Onde:

-   $r_t$ √© o log-retorno no tempo $t$.
-   $\mu$ √© a m√©dia dos retornos.
-   $\epsilon_t$ √© o termo de erro, condicionado √†s informa√ß√µes passadas.
-   $\sigma_t^2$ √© a vari√¢ncia condicional no tempo $t$.
-   $\omega, \alpha, \beta$ s√£o os par√¢metros a serem estimados, com $\omega > 0, \alpha \geq 0, \beta \geq 0$.
-   $z_t$ segue uma distribui√ß√£o $t$ de Student com $ŒΩ$ graus de liberdade para capturar as caudas pesadas observadas em retornos financeiros.

A soma $\alpha + \beta$ √© frequentemente utilizada para medir a persist√™ncia da volatilidade: quanto mais pr√≥ximos de 1, maior a persist√™ncia dos choques na volatilidade.

Vamos estimar a vari√¢ncia condicional ($\sigma^2_{t}$ ) para cada ativo:

```{python}

# Estimar o modelo GARCH(1,1) e salvar vari√¢ncia condicional
var_condicional = pd.DataFrame({"date": log_returns["date"]})

for col in log_returns.columns[1:]:
    am = arch_model(log_returns[col], vol="Garch", p=1, q=1, dist="t")
    res = am.fit(disp="off")
    var_condicional[col] = res.conditional_volatility ** 2

var_condicional.head()

```

Vamos avaliar os par√¢metros estimados do modelo:

```{python}

# Inferir sobre os par√¢metros do modelo GARCH(1,1) para cada ativo do portf√≥lio

params_list = []

# Iterar sobre cada ativo (exceto a coluna 'date')
for col in log_returns.columns[1:]:
    am = arch_model(log_returns[col], vol="Garch", p=1, q=1, dist="t")
    res = am.fit(disp="off")
    
    par = res.params
    alpha_val = par.get("alpha[1]", None)
    beta_val  = par.get("beta[1]", None)
    alpha_beta_sum = (alpha_val if alpha_val is not None else 0) + (beta_val if beta_val is not None else 0)
    
    # Interpreta√ß√£o curta
    if alpha_beta_sum >= 0.9:
        interp = f"Alta persist√™ncia (Œ±+Œ≤ = {alpha_beta_sum:.4f})."
    else:
        interp = f"Baixa/moderada persist√™ncia (Œ±+Œ≤ = {alpha_beta_sum:.4f})."
    
    params_list.append({
         "Ativo": col,
         "mu": par.get("mu", None),
         "omega": par.get("omega", None),
         "alpha": alpha_val,
         "beta": beta_val,
         "alpha+beta": alpha_beta_sum,
         "nu": par.get("nu", None),
         "Interpretacao": interp
    })

garch_params = pd.DataFrame(params_list)

```

A soma $\alpha + \beta$ √© um indicador crucial na modelagem GARCH para avaliar a persist√™ncia da volatilidade. Em termos pr√°ticos, os par√¢metros $\alpha$ e $\beta$ t√™m fun√ß√µes distintas:

-   $\alpha$: Representa o impacto dos choques recentes (a inova√ß√£o ou termo de erro $\epsilon_{t-1}^2$ na volatilidade atual. Um valor mais alto de $\alpha$ indica que choques recentes t√™m um efeito maior em aumentar a volatilidade.
-   $\beta$: Captura a persist√™ncia da volatilidade ao longo do tempo, ou seja, o efeito da volatilidade passada ($\sigma_{t-1}^2)$ sobre a volatilidade presente. Valores maiores de $\beta$ sugerem que a volatilidade tende a se manter elevada por um per√≠odo mais longo.

Quando somamos esses dois par√¢metros, ou seja, quando calculamos $\alpha + \beta$, obtemos uma medida da persist√™ncia total da volatilidade:

-   Se $\alpha + \beta$ estiver **pr√≥ximo de 1**, isso indica que os choques que afetam a volatilidade t√™m efeitos de longa dura√ß√£o. Em outras palavras, um choque na volatilidade tem um impacto que se dissipa muito lentamente, mantendo a volatilidade elevada por v√°rios per√≠odos.
-   Se $\alpha + \beta$ for **significativamente menor que 1**, os efeitos dos choques s√£o de curta dura√ß√£o e a volatilidade retorna rapidamente ao seu n√≠vel m√©dio ap√≥s um impacto.

Em alguns casos, quando $\alpha + \beta = 1$, o modelo √© denominado **IGARCH** (Integrated GARCH), o que implica que os choques t√™m efeitos persistentes permanentemente, ou seja, a volatilidade n√£o reverte para um valor m√©dio fixo.

Esta caracter√≠stica √© particularmente importante na an√°lise de s√©ries financeiras, pois a persist√™ncia alta da volatilidade pode implicar maior risco de mercado e desafios na previs√£o dos retornos futuros. Assim, a soma $\alpha + \beta$ serve como uma medida de "mem√≥ria" dos choques, indicando se a volatilidade reage de forma passageira ou duradoura a eventos inesperados.

Graficamente temos:

```         
```

```{python}
#| eval: false

# Retire o comando #| eval: false pra conseguir executar essa celula dentro do Quarto
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Para o ativo "ZC=F"
returns_zc = log_returns[['date', 'BEEF3.SA']].copy()
vol_zc = var_condicional[['date', 'BEEF3.SA']].copy()

# Converter "date" para datetime, se necess√°rio
returns_zc['date'] = pd.to_datetime(returns_zc['date'])
vol_zc['date'] = pd.to_datetime(vol_zc['date'])

# Criar figura com dois subplots compartilhando o eixo x
fig = make_subplots(
    rows=2, cols=1,
    shared_xaxes=True,
    vertical_spacing=0.05,
    subplot_titles=("Retornos Di√°rios - BEEF3.SA", "Volatilidade Condicional (GARCH) - BEEF3.SA")
)

# Adicionar o gr√°fico de retornos
fig.add_trace(
    go.Scatter(x=returns_zc['date'], y=returns_zc['ZC=F'], mode='lines', name='Retornos'),
    row=1, col=1
)

# Adicionar o gr√°fico de volatilidade condicional
fig.add_trace(
    go.Scatter(x=vol_zc['date'], y=vol_zc['ZC=F'], mode='lines', name='Volatilidade'),
    row=2, col=1
)

fig.update_layout(
    height=600,
    width=900,
    title_text="Retorno vs. Volatilidade (GARCH) - ZC=F",
    xaxis2_title="Data",
    yaxis1_title="Retorno",
    yaxis2_title="Volatilidade Condicional"
)

fig.show()


```

Em alguns casos, a vari√¢ncia condicional pode apresentar grandes oscila√ß√µes se houver outliers nos retornos ou problemas de converg√™ncia do modelo. Verifique:

-   Qualidade e limpeza dos dados
-   Resumo do ajuste (par√¢metros $\alpha,\beta$ plaus√≠veis?)
-   Distribui√ß√£o ($t$ vs. normal)
-   Modelos alternativos (EGARCH, GJR-GARCH, etc.)

### Plotando retorno x risco

Aqui iremos visualizar o comportamento do ativo `ZC=F`, futuros de milho:

```         
```

Esse gr√°fico em Python, pode ser obtido com:

```{python}
#| eval: false

import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Para o ativo "ZC=F"
returns_zc = log_returns[['date', 'BEEF3.SA']].copy()
vol_zc = var_condicional[['date', 'BEEF3.SA']].copy()

# Converter "date" para datetime, se necess√°rio
returns_zc['date'] = pd.to_datetime(returns_zc['date'])
vol_zc['date'] = pd.to_datetime(vol_zc['date'])

# Criar figura com dois subplots compartilhando o eixo x
fig = make_subplots(
    rows=2, cols=1,
    shared_xaxes=True,
    vertical_spacing=0.05,
    subplot_titles=("Retornos Di√°rios - BEEF3.SA", "Volatilidade Condicional (GARCH) - BEEF3.SA")
)

# Adicionar o gr√°fico de retornos
fig.add_trace(
    go.Scatter(x=returns_zc['date'], y=returns_zc['BEEF3.SA'], mode='lines', name='Retornos'),
    row=1, col=1
)

# Adicionar o gr√°fico de volatilidade condicional
fig.add_trace(
    go.Scatter(x=vol_zc['date'], y=vol_zc['BEEF3.SA'], mode='lines', name='Volatilidade'),
    row=2, col=1
)

fig.update_layout(
    height=600,
    width=900,
    title_text="Retorno vs. Volatilidade (GARCH) - BEEF3.SA",
    xaxis2_title="Data",
    yaxis1_title="Retorno",
    yaxis2_title="Volatilidade Condicional"
)

fig.show()

```
:::

------------------------------------------------------------------------

# References

------------------------------------------------------------------------

Gujarati, D. N., & Porter, D. C. (2009). **Basic econometrics** (5th ed.). McGraw-Hill.

Hyndman, R.J., & Athanasopoulos, G. (2021) **Forecasting: principles and practice**, 3rd edition, OTexts: Melbourne, Australia. OTexts.com/fpp3. Accessed on march 2025.\