<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>page5 – Projeto Finanças</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ddd961a2510921635943dfbbd19534c4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Projeto Finanças</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">Sobre</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./appdash.html"> 
<span class="menu-text">Dashboard</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./page2.html"> 
<span class="menu-text">Logs de Retorno</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./page3.html"> 
<span class="menu-text">Futuro</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./page4.html"> 
<span class="menu-text">Forecasting</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/FinancasFae"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#configuração-do-python-com-reticulate" id="toc-configuração-do-python-com-reticulate" class="nav-link active" data-scroll-target="#configuração-do-python-com-reticulate">Configuração do Python com <code>reticulate</code></a></li>
  <li><a href="#aquisição-de-dados-de-preços" id="toc-aquisição-de-dados-de-preços" class="nav-link" data-scroll-target="#aquisição-de-dados-de-preços">2. Aquisição de Dados de Preços</a></li>
  <li><a href="#preparação-e-análise-exploratória-dos-dados-python" id="toc-preparação-e-análise-exploratória-dos-dados-python" class="nav-link" data-scroll-target="#preparação-e-análise-exploratória-dos-dados-python">3. Preparação e Análise Exploratória dos Dados (Python)</a></li>
  <li><a href="#forecasting-de-preços-python-com-plotly" id="toc-forecasting-de-preços-python-com-plotly" class="nav-link" data-scroll-target="#forecasting-de-preços-python-com-plotly">4. Forecasting de Preços (Python com Plotly)</a></li>
  <li><a href="#reinforcement-learning-para-sinais-de-trading" id="toc-reinforcement-learning-para-sinais-de-trading" class="nav-link" data-scroll-target="#reinforcement-learning-para-sinais-de-trading">5. Reinforcement Learning para Sinais de Trading</a>
  <ul class="collapse">
  <li><a href="#definição-do-agente-e-funções-auxiliares" id="toc-definição-do-agente-e-funções-auxiliares" class="nav-link" data-scroll-target="#definição-do-agente-e-funções-auxiliares">5.1. Definição do Agente e Funções Auxiliares</a></li>
  <li><a href="#treinamento-do-agente-rl" id="toc-treinamento-do-agente-rl" class="nav-link" data-scroll-target="#treinamento-do-agente-rl">5.2. Treinamento do Agente RL</a></li>
  <li><a href="#geração-de-sinais-de-trading-e-visualização" id="toc-geração-de-sinais-de-trading-e-visualização" class="nav-link" data-scroll-target="#geração-de-sinais-de-trading-e-visualização">5.3. Geração de Sinais de Trading e Visualização</a></li>
  </ul></li>
  <li><a href="#conclusão" id="toc-conclusão" class="nav-link" data-scroll-target="#conclusão">6. Conclusão</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<pre><code>---
title: "Análise de Carteira com Forecasting e Reinforcement Learning"
format:
  html:
    embed-resources: true
    toc: true
    code-fold: true
    code-summary: "Mostrar/Ocultar Código"
editor: visual
---</code></pre>
<section id="configuração-do-python-com-reticulate" class="level3">
<h3 class="anchored" data-anchor-id="configuração-do-python-com-reticulate">Configuração do Python com <code>reticulate</code></h3>
<p>Certifique-se de que o ambiente Python que você especificar abaixo tenha todas as bibliotecas Python necessárias instaladas: <code>yahooquery</code>, <code>gymnasium</code>, <code>torch</code>, <code>numpy</code>, <code>pandas</code>, <code>matplotlib</code>, <code>yfinance</code>, <code>plotly</code>.</p>
<pre><code>## 1. Configuração do Ambiente

Primeiro, vamos carregar as bibliotecas R necessárias e configurar o reticulate para usar nosso ambiente Python.

### Bibliotecas R
::: {.cell}

```{.r .cell-code}
# Bibliotecas R
library(tidyverse) # Para manipulação de dados e ggplot2
library(plotly)    # Para gráficos interativos (se for recriar em R)
library(reticulate)  # Para executar código Python
library(dplyr)     # Especificamente para a função de busca de dados
library(quantmod)  # Para buscar dados financeiros

#| label: setup-python-environment
#| echo: true

# EXEMPLES - DESCOMENTE O QUE VOCÊ PRECISA E AJUSTE OS CAMINHOS
# Exemplo de como especificar um ambiente conda:
# use_condaenv("seu_ambiente_conda", required = TRUE)

# Ou um ambiente virtual:
# use_virtualenv("/caminho/para/seu/ambiente_virtual", required = TRUE)

# Ou especificar o executável Python diretamente:
# use_python("/usr/bin/python3", required = TRUE) # Ajuste o caminho conforme necessário

# Se as bibliotecas não estiverem instaladas, você pode tentar instalá-las via reticulate:
# py_install(c("yahooquery", "gymnasium", "torch", "numpy", "pandas", "matplotlib", "yfinance", "plotly"), pip = TRUE)

# É altamente recomendável configurar seu ambiente Python aqui ou no seu arquivo .Rprofile.
# Para fins de demonstração, tentaremos usar um ambiente padrão se não for especificado.
# Você pode precisar ajustar esta linha com base na configuração do Python do seu sistema.
# Exemplo: se você tem o miniconda instalado no seu diretório home:
# use_condaenv("r-reticulate", required = FALSE) # Substitua pelo seu nome de ambiente real ou remova se estiver usando o padrão</code></pre>
<p>:::</p>
<pre><code>#| label: python-library-imports
#| message: false
#| warning: false

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from yahooquery import Ticker
import yfinance as yf
from collections import deque

import gymnasium as gym
from gymnasium import spaces

import torch
import torch.nn as nn
import torch.optim as optim

from plotly.subplots import make_subplots
import plotly.graph_objects as go
import plotly.express as px

import warnings
warnings.filterwarnings("ignore")

print("Bibliotecas Python importadas com sucesso.")</code></pre>
</section>
<section id="aquisição-de-dados-de-preços" class="level2">
<h2 class="anchored" data-anchor-id="aquisição-de-dados-de-preços">2. Aquisição de Dados de Preços</h2>
<p>Utilizaremos um script R para buscar os preços de fechamento ajustados para os tickers selecionados e salvá-los em um arquivo CSV.</p>
<pre><code>#| label: define-fetch-function
#| message: false
#| warning: false

fetch_close_prices_qm &lt;- function(tickers, start, end, cache_path = "prices_qm.csv") {
  # Se já existe CSV em cache, carrega e retorna
  if (file.exists(cache_path)) {
    df &lt;- read.csv(cache_path, stringsAsFactors = FALSE) %&gt;%
      mutate(date = as.Date(date))
    message("Dados carregados do cache: ", cache_path)
    return(df)
  }

  # Senão, faz o download para cada ticker
  all_data &lt;- lapply(tickers, function(tk) {
    # getSymbols retorna um objeto xts com colunas Open, High, Low, Close, Volume, Adjusted
    xts_data &lt;- tryCatch({
        getSymbols(tk, src = "yahoo", from = start, to = end, auto.assign = FALSE)
    }, error = function(e) {
        message(paste("Erro ao buscar dados para", tk, ":", e$message))
        return(NULL)
    })

    if (is.null(xts_data)) return(NULL)

    # Prioriza Adjusted, se não disponível, usa Close
    if ("Adjusted" %in% colnames(xts_data)) {
      price_col &lt;- Ad(xts_data)  # Preço Ajustado
    } else if ("Close" %in% colnames(xts_data)) {
      message(paste0("⚠️ Usando 'Close' para ", tk, ", pois 'Adj Close' não está disponível ou está vazio."))
      price_col &lt;- Cl(xts_data)  # Preço de Fechamento
    } else {
      message(paste0("❌ Não foi possível encontrar dados de 'Adj Close' ou 'Close' para ", tk, ". Ignorando este ticker."))
      return(NULL)
    }

    data.frame(
      date   = index(price_col),
      ticker = tk,
      close  = as.numeric(price_col),
      row.names = NULL
    )
  })

  # Remove NULLs (tickers com erro) e combina
  all_data &lt;- all_data[!sapply(all_data, is.null)]
  if (length(all_data) == 0) {
    stop("Nenhum dado foi baixado para os tickers especificados.")
  }
  df &lt;- bind_rows(all_data)

  # Salva em CSV para próximas execuções
  write.csv(df, cache_path, row.names = FALSE)
  message("Dados salvos no cache: ", cache_path)

  return(df)
}</code></pre>
<pre><code>#| label: r-data-acquisition #| message: true #| warning: false  tickers &lt;- c("BRFS3.SA", "JBSS3.SA", "BEEF3.SA", "MRFG3.SA", "TSN", "HRL", "GIS") start_date &lt;- "2020-01-01" end_date &lt;- format(Sys.Date(), "%Y-%m-%d") # Usar data atual para 'to'  df_prices_r &lt;- fetch_close_prices_qm(tickers, start_date, end_date, cache_path = "prices_analise.csv") tail(df_prices_r) </code></pre>
</section>
<section id="preparação-e-análise-exploratória-dos-dados-python" class="level2">
<h2 class="anchored" data-anchor-id="preparação-e-análise-exploratória-dos-dados-python">3. Preparação e Análise Exploratória dos Dados (Python)</h2>
<p>Carregamos os dados do CSV em um DataFrame pandas e o pivotamos para facilitar a análise por ticker.</p>
<pre><code>#| label: r-data-acquisition
#| message: true
#| warning: false

tickers &lt;- c("BRFS3.SA", "JBSS3.SA", "BEEF3.SA", "MRFG3.SA", "TSN", "HRL", "GIS")
start_date &lt;- "2020-01-01"
end_date &lt;- format(Sys.Date(), "%Y-%m-%d") # Usar data atual para 'to'

df_prices_r &lt;- fetch_close_prices_qm(tickers, start_date, end_date, cache_path = "prices_analise.csv")
tail(df_prices_r)
#| label: python-data-prep

import pandas as pd
# Carregar dados do CSV salvo pelo R
df_prices = pd.read_csv('prices_analise.csv', parse_dates=['date'])
print("Tail do df_prices carregado:")
print(df_prices.tail())

# Pivotear somente as colunas 'ticker' e 'close'
df_pivot = df_prices.pivot(index='date', columns='ticker', values='close')
df_pivot = df_pivot.reset_index() # Manter 'date' como coluna

print("\nTail do df_pivot:")
print(df_pivot.tail())</code></pre>
</section>
<section id="forecasting-de-preços-python-com-plotly" class="level2">
<h2 class="anchored" data-anchor-id="forecasting-de-preços-python-com-plotly">4. Forecasting de Preços (Python com Plotly)</h2>
<p>Realizamos uma simulação simples de forecasting baseada na média e desvio padrão dos retornos logarítmicos históricos.</p>
<pre><code>#| label: python-forecasting
#| fig-cap: "Forecasting de Preços para os Tickers da Carteira (Próximos 30 dias)"
#| fig-width: 10
#| fig-height: 8 # Ajustado dinamicamente com base no número de tickers

import numpy as np
import pandas as pd
import plotly.express as px

# Defina a data de corte e o período do forecast
# Usar a data mais recente do df_pivot como CUT
CUT = df_pivot["date"].max()
forecast_days = 30
future_dates = pd.date_range(CUT + pd.Timedelta(days=1), periods=forecast_days, freq="D")

# Lista de ativos (tickers)
assets = df_pivot.columns[1:]  # Ignorando a coluna 'date'

# Lista para armazenar os dados de forecast
forecast_data = []

# Gera previsões para cada ativo (simulação simples)
for asset in assets:
    # Pega os dados históricos até a data de corte
    df_asset_hist = df_pivot[["date", asset]].copy()
    df_asset_hist = df_asset_hist[df_asset_hist["date"] &lt;= CUT]
    df_asset_hist.dropna(subset=[asset], inplace=True)

    if len(df_asset_hist) &lt; 2:
        print(f"Dados insuficientes para forecasting do ativo: {asset}. Pulando.")
        continue

    # Calcula a média e desvio padrão dos retornos históricos
    df_asset_hist["logret"] = df_asset_hist[asset].pct_change()
    df_asset_hist.replace([np.inf, -np.inf], np.nan, inplace=True)
    df_asset_hist.dropna(subset=['logret'], inplace=True)

    if df_asset_hist["logret"].empty:
        print(f"Não foi possível calcular retornos para o ativo: {asset}. Usando defaults.")
        mu = 0
        sigma = 0.01
    else:
        mu = df_asset_hist["logret"].mean()
        sigma = df_asset_hist["logret"].std()
        if pd.isna(sigma) or sigma == 0:
            sigma = 0.01

    # Simula os retornos futuros
    last_price = df_asset_hist[asset].iloc[-1]
    if pd.isna(last_price):
        print(f"Último preço é NaN para o ativo: {asset}. Pulando forecast.")
        continue

    simulated_logrets = np.random.normal(loc=mu, scale=sigma, size=forecast_days)
    simulated_prices = last_price * (1 + simulated_logrets).cumprod()

    # Adiciona os dados de forecast
    for date_val, value in zip(future_dates, simulated_prices):
        forecast_data.append({
            "date": date_val,
            "asset": asset,
            "price": value,
            "rep": "Forecast"
        })

df_forecast = pd.DataFrame(forecast_data)

# Prepara o histórico para plotar junto, filtrando até a data de corte
hist_data = df_pivot[df_pivot["date"] &lt;= CUT].copy()
hist_data = hist_data.melt(id_vars="date", var_name="asset", value_name="price")
hist_data["rep"] = "Histórico"

# Junta histórico e forecast
df_plot = pd.concat([hist_data, df_forecast], ignore_index=True)

# Filtra os dados para mostrar apenas o período relevante (últimos N dias de histórico + forecast)
start_plot_date = CUT - pd.Timedelta(days=60)
end_plot_date = CUT + pd.Timedelta(days=forecast_days)

df_plot_filtered = df_plot[(df_plot["date"] &gt;= start_plot_date) &amp; (df_plot["date"] &lt;= end_plot_date)]

if not df_plot_filtered.empty:
    fig_forecast = px.line(
        df_plot_filtered,
        x="date",
        y="price",
        color="rep",
        facet_col="asset",
        facet_col_wrap=2,
        labels={"date": "Data", "price": "Preço (Moeda Local/USD)", "rep": "Série"},
        title=f"Forecasting de Preços ({forecast_days} dias) a partir de {CUT.strftime('%Y-%m-%d')}"
    )
    # Ajusta a altura da figura dinamicamente com base no número de ativos
    num_rows = (len(assets) + 1) // 2 # Divisão inteira, arredonda para cima
    fig_forecast.update_layout(width=1000, height=300 * num_rows)
    fig_forecast.update_xaxes(matches=None, nticks=5)
    fig_forecast.show()
else:
    print("Nenhum dado para plotar no gráfico de forecast.")</code></pre>
</section>
<section id="reinforcement-learning-para-sinais-de-trading" class="level2">
<h2 class="anchored" data-anchor-id="reinforcement-learning-para-sinais-de-trading">5. Reinforcement Learning para Sinais de Trading</h2>
<section id="definição-do-agente-e-funções-auxiliares" class="level3">
<h3 class="anchored" data-anchor-id="definição-do-agente-e-funções-auxiliares">5.1. Definição do Agente e Funções Auxiliares</h3>
<p>Definimos a função <code>getState</code> e a classe <code>Agent</code> que representa nosso agente de RL.</p>
<pre><code>#| label: python-rl-agent

import numpy as np
import torch
import torch.nn as nn

def getState(data, t, window_size):
    """
    Converte uma janela de preços em vetor de retornos normalizados.
    """
    d = t - window_size + 1
    block = data[d:t+1] if d &gt;= 0 else -d * [data[0]] + list(data[0:t+1])
    # Evitar divisão por zero se block[i] for 0
    res = []
    for i in range(len(block)-1):
        if block[i] != 0:
            res.append((block[i+1] - block[i]) / block[i])
        else:
            res.append(0) # Retorno zero se o preço base for zero
    return np.array(res, dtype=np.float32)

class Agent(nn.Module):
    def __init__(
        self,
        state_size,
        hidden_size=64,
        lr=1e-4,
        gamma=0.95,
        epsilon=1.0,
        epsilon_min=0.01,
        epsilon_decay=0.995
    ):
        super(Agent, self).__init__()
        self.gamma = gamma
        self.epsilon = epsilon
        self.epsilon_min = epsilon_min
        self.epsilon_decay = epsilon_decay
        self.inventory = [] # Adicionado para manter o inventário do agente

        self.model = nn.Sequential(
            nn.Linear(state_size, hidden_size),
            nn.ReLU(),
            nn.Linear(hidden_size, 3)  # Q para 3 ações: 0=HOLD, 1=BUY, 2=SELL
        )
        self.optimizer = optim.Adam(self.model.parameters(), lr=lr)
        self.criterion = nn.MSELoss()

    def act(self, state):
        if np.random.rand() &lt; self.epsilon:
            return np.random.choice([0,1,2]) # 0: HOLD, 1: BUY, 2: SELL
        state_t = torch.from_numpy(state).unsqueeze(0)
        q_values = self.model(state_t).detach().numpy()[0]
        return np.argmax(q_values)

    def train_step(self, state, action, reward, next_state, done):
        state_t = torch.from_numpy(state).unsqueeze(0)
        next_t = torch.from_numpy(next_state).unsqueeze(0)

        q_values = self.model(state_t)

        with torch.no_grad():
            q_next = self.model(next_t).max(1)[0]
            if done: # Se for o estado terminal, o valor do próximo estado é 0
                 target_q_value = reward
            else:
                 target_q_value = reward + self.gamma * q_next

        target = q_values.clone().detach()
        target[0, action] = target_q_value

        loss = self.criterion(q_values, target)
        self.optimizer.zero_grad()
        loss.backward()
        self.optimizer.step()

        if self.epsilon &gt; self.epsilon_min:
            self.epsilon *= self.epsilon_decay

print("Definições do Agente RL carregadas.")</code></pre>
</section>
<section id="treinamento-do-agente-rl" class="level3">
<h3 class="anchored" data-anchor-id="treinamento-do-agente-rl">5.2. Treinamento do Agente RL</h3>
<p>Treinamos o agente para cada ticker da nossa lista.</p>
<pre><code>#| label: python-rl-training
#| fig-cap: "Evolução do Lucro Total por Episódio Durante o Treinamento do Agente RL"
#| fig-width: 10
#| fig-height: 6

import numpy as np
import torch
import torch.nn as nn
import plotly.express as px # Garantir que plotly está importado para plotagem

# Parâmetros de treinamento
window_size = 10
episodes    = 50
rl_results  = {}

# Tickers para o treinamento (obtidos do df_pivot)
train_tickers = df_pivot.columns[1:].tolist()

for tk in train_tickers:
    print(f"\n=== Treinando para {tk} ===")

    # Prepara série de preços para o ticker
    prices = df_prices[df_prices['ticker'] == tk].sort_values("date")['close'].values
    prices = prices[~np.isnan(prices)] # Remover NaNs dos preços

    if len(prices) &lt; window_size + 2:
        print(f"Dados insuficientes para {tk} após remover NaNs. Pulando ticker.")
        # Garante que uma lista de 0s seja adicionada para evitar erros se este ticker for pulado
        rl_results[tk] = [0] * episodes
        continue

    agent = Agent(state_size=window_size)
    total_profits_tk = []

    for e in range(episodes):
        # getState espera window_size + 1 para gerar 'window_size' retornos
        state = getState(prices, 0, window_size + 1)
        agent.inventory = []
        total_profit = 0.0

        for t in range(len(prices) - 1): # Loop até o penúltimo preço
            action = agent.act(state)
            next_state = getState(prices, t + 1, window_size + 1)
            reward = 0.0
            done = (t == len(prices) - 2)

            # Executa ação: BUY, SELL ou HOLD
            if action == 1:  # BUY
                agent.inventory.append(prices[t])
            elif action == 2 and agent.inventory:  # SELL
                bought_price = agent.inventory.pop(0)
                profit = prices[t] - bought_price
                if bought_price != 0:
                    reward = profit / bought_price
                else:
                    reward = 0.0
                total_profit += profit

            agent.train_step(state, action, reward, next_state, done)
            state = next_state

        total_profits_tk.append(total_profit)
        if (e + 1) % 10 == 0 or e == episodes - 1:
            print(f"Episódio {e+1}/{episodes} — Lucro: {total_profit:.2f}")

    rl_results[tk] = total_profits_tk

# Plot da evolução do lucro
if rl_results:
    df_hist_profit = pd.DataFrame(rl_results)
    df_hist_profit = df_hist_profit.reset_index().rename(columns={'index': 'Episódio'})

    df_melt_profit = df_hist_profit.melt(
        id_vars='Episódio',
        var_name='ticker',
        value_name='Lucro'
    )

    fig_profit_evol = px.line(
        df_melt_profit,
        x='Episódio',
        y='Lucro',
        color='ticker',
        title='Evolução do Lucro Total por Episódio (Treinamento RL)'
    )
    fig_profit_evol.update_layout(
        xaxis_title='Episódio',
        yaxis_title='Lucro Total (Moeda Local/USD)'
    )
    fig_profit_evol.show()
else:
    print("Nenhum resultado de treinamento RL para plotar.") </code></pre>
</section>
<section id="geração-de-sinais-de-trading-e-visualização" class="level3">
<h3 class="anchored" data-anchor-id="geração-de-sinais-de-trading-e-visualização">5.3. Geração de Sinais de Trading e Visualização</h3>
<p>Após o treinamento, usamos o agente para gerar sinais de COMPRA/VENDA e os visualizamos.</p>
<pre><code>#| label: python-rl-signals
#| fig-cap: "Sinais de Compra/Venda Gerados pelo Agente RL por Ticker"
#| fig-width: 10
#| fig-height: 12 # Ajustado dinamicamente com base no número de tickers

import numpy as np
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import torch
import torch.nn as nn

# 1) Gera sinais para cada ticker
all_signals = {}

# Reuso do último agente treinado. Idealmente, você teria um agente salvo por ticker
# ou um agente geral treinado em todos os dados.
if 'agent' not in locals() or agent is None:
    print("Agente não definido ou treinado. Tentando treinar um agente de demonstração.")
    # Encontra um ticker com dados suficientes para treinar um agente demo
    tk_demo_found = False
    for tk_candidate in train_tickers:
        prices_candidate = df_prices[df_prices['ticker'] == tk_candidate].sort_values("date")['close'].values
        prices_candidate = prices_candidate[~np.isnan(prices_candidate)]
        if len(prices_candidate) &gt;= window_size + 2:
            agent = Agent(state_size=window_size)
            # Treinamento rápido para agente de demonstração
            for e_demo in range(5):
                state_demo = getState(prices_candidate, 0, window_size + 1)
                for t_demo in range(len(prices_candidate) - 1):
                    action_demo = agent.act(state_demo)
                    next_state_demo = getState(prices_candidate, t_demo + 1, window_size + 1)
                    agent.train_step(state_demo, action_demo, 0, next_state_demo, (t_demo == len(prices_candidate) - 2))
                    state_demo = next_state_demo
            tk_demo_found = True
            print(f"Agente de demonstração treinado em {tk_candidate}.")
            break
    if not tk_demo_found:
        agent = None
        print("Não foi possível treinar um agente de demonstração. Pulando geração de sinais.")

if agent:
    for tk_signal in train_tickers:
        agent.epsilon = agent.epsilon_min # Usar política greedy para geração de sinais

        current_prices_tk = df_prices[df_prices.ticker==tk_signal].sort_values('date')

        if current_prices_tk.empty or 'close' not in current_prices_tk.columns:
            print(f"Aviso: Nenhum dado de preço para {tk_signal} na geração de sinais. Pulando.")
            all_signals[tk_signal] = pd.DataFrame(columns=['date', 'action', 'price'])
            continue

        dates_signal = current_prices_tk['date'].values
        values_signal = current_prices_tk['close'].values
        values_signal = values_signal[~np.isnan(values_signal)] # Remover NaNs

        if len(values_signal) &lt; window_size + 2:
            print(f"Dados insuficientes para {tk_signal} na geração de sinais após remover NaNs. Pulando.")
            all_signals[tk_signal] = pd.DataFrame(columns=['date', 'action', 'price'])
            continue

        state_signal = getState(values_signal, 0, window_size+1)
        agent.inventory = [] # Resetar inventário para cada ticker
        signals_current_tk = []

        for t_signal in range(len(values_signal)-1):
            action_signal = agent.act(state_signal)
            date_val = dates_signal[t_signal]
            price_val = values_signal[t_signal]

            if action_signal == 1: # BUY
                signals_current_tk.append({'date': date_val, 'action': 'BUY',  'price': price_val})
                agent.inventory.append(price_val)
            elif action_signal == 2 and agent.inventory: # SELL
                signals_current_tk.append({'date': date_val, 'action': 'SELL', 'price': price_val})
                agent.inventory.pop(0)

            next_state_signal = getState(values_signal, t_signal+1, window_size+1)
            state_signal = next_state_signal

        if signals_current_tk:
            all_signals[tk_signal] = pd.DataFrame(signals_current_tk)
        else:
            all_signals[tk_signal] = pd.DataFrame(columns=['date', 'action', 'price'])
else:
    print("Agente RL não está definido. Pulando geração e visualização de sinais.")
    all_signals = {tk: pd.DataFrame(columns=['date', 'action', 'price']) for tk in train_tickers}


# 2) Cria figura com uma linha por ticker
if train_tickers and all_signals:
    fig_signals = make_subplots(
        rows=len(train_tickers), cols=1,
        shared_xaxes=True,
        subplot_titles=train_tickers,
        vertical_spacing=0.02
    )

    for i, tk_plot in enumerate(train_tickers, start=1):
        prices_tk_plot = df_prices[df_prices.ticker==tk_plot].sort_values('date')
        sig_df_plot = all_signals.get(tk_plot, pd.DataFrame(columns=['date', 'action', 'price']))

        if not prices_tk_plot.empty and 'close' in prices_tk_plot.columns:
            fig_signals.add_trace(
                go.Scatter(x=prices_tk_plot['date'], y=prices_tk_plot['close'], mode='lines', name=f'Preço {tk_plot}', legendgroup=f'group{tk_plot}'),
                row=i, col=1
            )

        buy_signals_plot = sig_df_plot.query("action=='BUY'")
        if not buy_signals_plot.empty:
            fig_signals.add_trace(
                go.Scatter(x=buy_signals_plot['date'],
                           y=buy_signals_plot['price'],
                           mode='markers', marker_symbol='triangle-up',
                           marker_size=8, marker_color='green',
                           name=f'Compra', showlegend=(i==1), legendgroup=f'group_buy'),
                row=i, col=1
            )

        sell_signals_plot = sig_df_plot.query("action=='SELL'")
        if not sell_signals_plot.empty:
            fig_signals.add_trace(
                go.Scatter(x=sell_signals_plot['date'],
                           y=sell_signals_plot['price'],
                           mode='markers', marker_symbol='triangle-down',
                           marker_size=8, marker_color='red',
                           name=f'Venda', showlegend=(i==1), legendgroup=f'group_sell'),
                row=i, col=1
            )

    fig_signals.update_layout(
        height=max(300 * len(train_tickers), 800),
        title_text='Sinais de Compra/Venda por Ticker (Agente RL)',
        legend_tracegroupgap = 180
    )
    fig_signals.update_yaxes(title_text="Preço")
    # Aplica o título do eixo X apenas ao último subplot visível
    last_row_with_data = 0
    if train_tickers:
        for r_idx, tk_name in enumerate(train_tickers):
            if not df_prices[df_prices.ticker == tk_name].empty:
                last_row_with_data = r_idx + 1 # +1 porque as linhas são indexadas a partir de 1 nos subplots
    if last_row_with_data &gt; 0:
      fig_signals.update_xaxes(title_text="Data", row=last_row_with_data, col=1)

    fig_signals.show()
else:
    print("Nenhum ticker ou sinal para plotar.")</code></pre>
</section>
</section>
<section id="conclusão" class="level2">
<h2 class="anchored" data-anchor-id="conclusão">6. Conclusão</h2>
<p>Este documento demonstrou um pipeline para análise de dados financeiros, incluindo coleta de dados, forecasting e a aplicação de um agente de Reinforcement Learning para gerar sinais de trading. Os resultados visuais do forecasting e dos sinais do agente RL fornecem insights que podem auxiliar na tomada de decisões de investimento, lembrando sempre da importância de análises complementares e do gerenciamento de risco.</p>
<p>Os gráficos de evolução do lucro durante o treinamento do agente RL indicam a capacidade de aprendizado do modelo em diferentes ativos, embora a performance possa variar significativamente. A visualização final dos sinais de compra e venda sobrepostos aos preços históricos permite uma avaliação qualitativa da estratégia do agente.<br>
</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>